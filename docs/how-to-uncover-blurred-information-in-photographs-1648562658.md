# 如何发现照片中模糊的信息

> 原文：<https://lifehacker.com/how-to-uncover-blurred-information-in-photographs-1648562658>

当你在线分享图片时，模糊或像素化账号等敏感信息是一种常见的做法，但你的信息可能没有你想象的那么安全。这需要一些工作，但有一些方法来揭示这一敏感文本。



*这篇文章是我们 Lifehacker 的* [*邪恶周*](https://lifehacker.com/welcome-to-lifehackers-fifth-annual-evil-week-1647621043) *系列的一部分，在这里我们看到了做事的阴暗面。知道邪恶意味着知道如何打败它，所以你可以用你的邪恶力量做好事。想要更多吗？查看我们的* [*恶周标签页*](http://lifehacker.com/tag/evilweek) *。*

毫无疑问，你们都在电视和网上看到过被模糊化以隐藏面孔的人的照片。例如，这是比尔·盖茨的一张照片。

在很大程度上，这是一种审查人脸的好方法，因为没有一种方便的方法可以将模糊的图像还原成足够清晰可辨的照片。如果这是你的本意，那很好。然而，许多人也求助于模糊敏感的*数字*和*文本*。我将说明为什么这是一个坏主意。

假设有人出于某种原因在网上发布了他们的支票或信用卡的照片(向某人证明我赚了一百万美元，展示支票的一些有趣之处，将某物的大小与信用卡进行比较，等等)。)，用太常见的马赛克效果来审查图像以隐藏数字:

看起来很安全，因为没人能读懂这些数字了？不对。这里有一个攻击这个方案的方法:

### **第一步:获取空白支票图像**

有两种方法可以做到这一点。你可以将现有图像中的数字用 Photoshop 处理掉，或者在信用卡的情况下，你可以从同一组织获得一个帐户，从同一角度拍摄一张自己的卡，并匹配白平衡和对比度。然后，用你自己的高分辨率照片来 PS 出你的数字。

当然，在这些示例图像中这很容易:

### **第二步:重复各种可能性**

使用一个脚本来遍历所有可能的帐号，并为每个帐号生成一张支票，将数字的各个部分作为一个个部分。例如，对于 Visa 卡，数字按 4 分组，因此您可以单独完成每个部分，因此只需要生成 4*10000 = 40000 张图像，这对于脚本来说很容易。

### **步骤 3:以与原始图像相同的方式模糊每个图像**

确定用于模糊原始图像的马赛克拼贴的精确大小和偏移量(以像素为单位)，然后对每个模糊图像执行相同的操作。在这种情况下，我们看到模糊图像具有 8×8 像素的镶嵌单元，并且通过从图像的顶部开始计数来确定偏移(未示出):

现在我们遍历所有的图像，用和原始图像一样的方式模糊它们，得到如下结果:

### **步骤 4:识别每个模糊图像的马赛克亮度矢量**

这是什么意思？好吧，就拿 0000001(放大)的马赛克版来说吧:

...并且识别每个镶嵌区域的亮度等级(0-255)，以某种一致的方式将它们索引为 a=[a_1，a_2...，a_n]:

在这种情况下，账号 0000001 创建马赛克亮度向量 a(0000001)=[213，201，190，...].我们以类似的方式找到每个账号的 mozaic 亮度向量，使用脚本模糊每个图像并读取亮度。设 a(x)是账号 x 的函数，a(x)_i 表示从账号 x 得到的马赛克亮度矢量 a 的第*个*个矢量值，以上，a(0000001)_1 = 213。

我们现在对我们在网上或任何地方找到的原始支票图像做同样的事情，获得我们在此称为 z=[z_1，z_2，...z_n]:

### **步骤 4:找到与原始图像距离最近的迭代**

识别原始图像的马赛克亮度，称之为 z=[z_1，z_2，...z_n]，然后简单地计算每个账号(用 x 表示)的马赛克亮度向量的距离(首先归一化每个):

> d(x)= sqrt((a(x)_ 0/n(a(x))-z_0/n(z))^2+(a(x)_ 1/n(a(x))-z_1/n(z))^2+....)

其中 N(a(x))和 N(z)是归一化常数，由下式给出

> N(a(x)) = (a(x)_0^2 + a(x)_1 ^2 +)...)^2
> 
> N(z) = (z_0^2 + z_1 ^2 +)...)^2

现在，我们只需找到最低的 d(x)。对于信用卡，只有一小部分可能的数字验证了假设的可能信用卡号码，所以这也是一个简单的检查。

在上面的例子中，我们计算，例如，

> N(z) = sqrt(206^2+211^2+...) = 844.78459
> 
> N(a(0000001)) = 907.47837
> 
> N(a(0000002)) = 909.20647
> 
> ...

然后继续计算距离:

> <small>d(0000001) = 1.9363</small>
> 
> <small>d(0000002) = 1.9373</small>
> 
> <small>...</small>
> 
> <small>d(1124587) = 0.12566</small>
> 
> <small>d(1124588) = 0.00000</small>
> 
> ...

账号可能只是 1124588 吗？

“但是你用了你自己制作的容易破译的图像！”

在现实世界中，我们有照片，而不是在 Photoshop 中虚构的支票。由于相机角度、不完美的对齐等原因，我们会有文本失真。但这并不能阻止人类确定这些扭曲到底是什么，并创建一个脚本来应用它们！无论哪种方式，确定的最低的几个距离可以被认为是候选。尤其是在信用卡领域——数字被很好地分成四个一组，只有十分之一的数字是有效的——很容易从你的前几个最小距离中进行选择，这是最有可能的候选。

为了在真实照片上实现这一点，你需要做的一件重要的事情是改进距离算法。例如，除了提高性能的方法之外，您还可以重新编写上面的距离公式来标准化标准偏差。您还可以为每个镶嵌区域单独设置 RGB 或 HSV 值，您还可以使用脚本在每个方向上将文本扭曲几个像素，并进行比较(这仍然可以让您在快速 PC 上进行可行的比较)。你也可以使用类似于现有的最近形状算法的算法来帮助提高真实照片的可靠性。

所以，是的，我用一个图像来对抗它自己，并设计它在这里工作。但是该算法肯定可以改进，以适用于真实世界的照片。这只是一个概念证明。但有一点是肯定的:这是一个非常容易解决的问题。不要用简单的马赛克来模糊你的图像。您所做的只是减少仅包含账户数据的 log(10^N)/log(2 有效位的图像的信息量。当你发布这样的图片时，你希望*消除*个人信息，而不是*通过减少图片中的视觉信息量来掩盖*个人信息。

考虑在屏幕上创建一个 100x100 的图形。现在让我们说，我只是平均了整个图形，并用整个平均值替换了每个像素(即，将它变成单个像素的“马赛克”)。您刚刚创建了一个以 256^(10000)可能性开始的函数，并将其散列为 256 种可能性。很明显，没有办法用产生的 8 位信息将它还原成原始图像。但是，如果您知道原始图像是 10 种可能性中的一种，只需知道得到的 8 位数字，就可以很容易地成功确定使用了哪个原始图像。

### **字典密码攻击是如何相似的**

大多数 UNIX/Linux 系统管理员都知道/etc/passwd 或/etc/shadow 存储使用单向加密(如 Salt 或 MD5)加密的密码。这是相当安全的，因为没有人能够通过查看密码文本来解密密码。通过对用户登录时输入的密码执行相同的单向加密，并将该结果与存储的单向结果进行比较，来进行身份验证。如果两者匹配，用户就成功通过了身份验证。

众所周知，当用户选择字典中的单词作为密码时，单向加密方案很容易被破解。然后，攻击者要做的就是加密整个英语词典，将每个单词的密文与/etc/passwd 中存储的密文进行比较，并选择正确的单词作为密码。因此，用户通常被建议选择更复杂的密码，而不是单词。字典攻击可以这样来说明:

字典攻击和模糊图像攻击之间的相似之处在于模糊图像是一种单向加密方案。您正在将您的图像转换成另一个无法读取的图像。然而，由于账号通常只有数百万，我们可以汇编一个可能账号的“字典”——也就是说，从 00000001 到 9999999 的所有号码，例如，使用自动图像处理器将这些号码中的每一个 Photoshop 到空白支票的照片上，并模糊每个图像。在这一点上，人们可以简单地比较模糊的像素，看看什么*最*接近地匹配原始模糊的照片。

解决方法很简单:不要模糊你的图像！相反，只需给它们上色:

记住，你要给图像的观察者留下*没有*的信息，而不是模糊的信息。这似乎是一个复杂的恢复文本的方法，但真正的要点是，这是完全可能的。

[为什么模糊敏感信息不是个好主意](http://dheera.net/projects/blur)| dheera.net

* * *

[<small>*Dheera venkat Raman*</small>](http://dheera.net/)<small>*是美国麻省理工学院电气工程和计算机科学系的研究生。*T11】</small>

<small>*比尔·盖茨的照片。*T3】</small>

<small>*想看看你在 Lifehacker 上的作品？邮箱*</small> [<small>*安迪*</small>](mailto:andy@lifehacker.com) <small>*。*T15】</small>